# Askr Framework Technical Guide

**面向高级插件开发者和框架设计关注者的深度技术指南**

## 设计哲学与核心理念

### 统一的事件-响应范式

Askr Framework建立在一个简单而强大的概念之上：**一切皆事件，一切皆响应**。无论是来自QQ用户的消息、系统定时任务，还是插件初始化，都被抽象为"事件"。插件的唯一职责就是对事件做出响应。

这种设计带来了几个重要优势：

**概念简单性**：新手开发者只需理解"输入事件→处理逻辑→输出响应"这一模式，无需掌握复杂的异步编程、生命周期管理等概念。

**接口一致性**：所有插件都是纯函数，具有相同的接口模式。这种一致性让插件的行为可预测，框架的执行模型清晰。

**扩展性**：新的事件类型可以无缝集成到现有系统中，插件可以选择性地响应感兴趣的事件。

### 稳定性优先的设计权衡

在性能与稳定性之间，Askr Framework明确选择了稳定性。这个选择反映在几个关键设计决策中：

**进程隔离而不是协程并发**：虽然主流框架都采用协程模型追求更高性能，Askr选择了进程隔离。单个插件的错误、死循环或内存泄漏完全无法影响框架核心和其他插件。

**资源控制而不是运行效率**：框架主动限制插件的CPU时间、内存使用和执行时长。这些限制可能影响某些计算密集型插件的性能，但确保了系统的整体稳定性。

**防御性设计而不是信任开发者**：框架假设插件可能存在各种问题，并预先建立了多层保护机制，而不是信任开发者会编写完美的代码。

### 渐进式学习曲线

框架的接口设计支持从简单到复杂的渐进式学习：

**最小可用性**：一个3行代码的插件就能实现有意义的功能。

**按需复杂度**：开发者可以根据需要逐步引入更多概念（rawEvent、botContext、配置管理等），而不是一开始就面对全部复杂性。

**透明升级路径**：从简单插件到复杂插件的升级是平滑的，不需要推翻重写。

## 技术架构特性

### 混合并行架构

Askr Framework采用独特的"框架多线程 + 插件多进程"混合架构：

**框架层并发**：主框架使用多线程处理不同插件的启动和结果收集，实现真正的并行执行。

**插件层隔离**：每个插件在独立的子进程中运行，拥有完全隔离的内存空间和执行环境。

**通信机制**：通过multiprocessing.Pipe()进行进程间通信，传递事件数据和执行结果。

**立即响应机制**：插件完成即立即处理结果，无需等待其他插件，显著提升用户体验的响应速度。

这种架构实现了错误隔离、资源控制、并发性能和可调试性的完美结合。

### 智能事件过滤系统

框架扩展了OneBot 11标准，实现了前级事件过滤：

**群消息三级分类**：
- `MESSAGE_GROUP`：普通群消息
- `MESSAGE_GROUP_MENTION`：包含@机器人的消息  
- `MESSAGE_GROUP_BOT`：以指令前缀（`.` `/` `\`）开头的消息

**扩展事件机制**：`MESSAGE_GROUP_MENTION`类型的消息也会触发`MESSAGE_GROUP`类型的处理函数，让插件可以选择处理粗粒度或细粒度的事件。

**性能优化效果**：在典型的群聊机器人场景中，大部分普通群消息不会触发插件执行，显著减少了不必要的进程创建开销。

### botContext工具协议

Askr Framework为插件提供了类似MCP(Model Context Protocol)的标准化工具接口：

**历史记录查询**：`Librarian(eventIdentifier, eventCount)` - 查询私聊、群聊或特定类型事件的历史记录

**配置持久化**：`ConfigReader()` / `ConfigWriter(config)` - 读写插件专用的配置数据，自动命名空间隔离

**API调用**：`ApiCaller(action, data)` - 向NapCat发送查询类API请求

**设计特点**：
- **主子进程版本自适应**：框架自动选择合适的实现版本
- **错误容忍设计**：工具调用失败返回None或空值，不会中断插件执行
- **统一的错误处理策略**：所有工具都采用相同的错误处理模式

### 数据流分工设计

框架中的数据按照清晰的分工流动：

**输入数据分层**：
- `rawEvent`：完整的OneBot 11事件数据，供需要详细信息的插件使用
- `simpleEvent`：简化的事件数据，包含最常用的字段，降低使用门槛

**输出响应分类**：
- **字符串返回值**：自动转换为文本消息发送
- **字典返回值**：直接作为OneBot 11 API调用
- **列表返回值**：批量处理多个操作

**API调用分工**：
- **查询类API**（get_*）：通过`botContext["ApiCaller"]`调用，返回值用于决策
- **行动类API**（send_*、set_*）：通过插件返回值调用，返回值通常不重要

## 插件执行模型详解

### 三阶段生命周期

**1. 初始化阶段（INITIALIZER）**：
- **时机**：框架启动时串行执行
- **用途**：检查配置、验证API密钥、预加载数据
- **设计目标**：让事件处理函数可以基于假设运行，避免重复检查，提高效率
- **失败处理**：初始化失败的插件会被完全移除，因为其处理函数的假设条件无法建立

**2. 事件响应阶段**：
- **时机**：收到相应事件时并行执行
- **隔离特性**：独立子进程，完整的资源限制，绝对的错误隔离
- **监控机制**：实时监控CPU、内存、执行时间，超限自动终止

**3. 定时响应阶段（UNCONDITIONAL）**：
- **设计哲学**：保持事件-响应模式的一致性，响应人工制造的unconditional事件
- **调度特性**：整分钟保证而不是精确间隔，让插件可以基于时间做简单判断
- **间隔机制**：间隔N表示在分钟数能被N整除时执行，而非每隔N分钟执行

### 资源控制与监控

**多层次资源限制**：
- **CPU时间限制**：防止死循环和计算密集型任务
- **内存限制**：防止内存泄漏影响系统
- **墙钟时间限制**：防止阻塞调用导致的超时

**实时监控机制**：使用psutil库在主进程中持续监控子进程资源使用情况，一旦发现异常立即采取措施。

**优雅的错误处理**：
- **插件级错误隔离**：插件异常不会影响其他插件或主框架
- **错误转换统一**：插件异常统一转换为None返回值，避免复杂的错误传播
- **管理员通知可选**：关键错误可配置自动QQ通知管理员

## 性能与稳定性机制

### 性能优化策略

虽然优先考虑稳定性，框架仍在多个层面进行了性能优化：

**前端过滤优化**：通过群消息分类减少不必要的插件调用
**并行执行优化**：多插件真正并行，充分利用多核性能
**响应速度优化**：立即响应机制，插件完成即刻处理结果
**数据库优化**：WAL模式、索引优化、连接复用

**性能期望**：在典型使用场景中（指令机器人、骰娘等），框架的性能表现与协程框架相近。

### 稳定性保障体系

**多层防护机制**：
- **进程级错误隔离**：最强的错误隔离级别
- **资源耗尽保护**：防止插件耗尽系统资源
- **自动故障恢复**：异常插件自动终止，不影响后续执行
- **紧急控制机制**：mute/unmute管理员命令

**可观测性支持**：
- **详细日志记录**：所有关键操作都有日志记录
- **错误通知系统**：可配置的QQ实时通知
- **执行统计指标**：插件执行时间、成功率等监控数据

## 开发指南与最佳实践

### 插件设计原则

**功能设计**：
- 保持插件功能单一、职责明确
- 充分利用INITIALIZER进行预处理和配置检查
- 合理选择事件类型，避免过度触发

**性能考虑**：
- 在INITIALIZER中完成耗时的初始化工作
- 使用ApiCaller进行查询，返回值进行行动
- 避免长时间阻塞操作和资源密集计算

**稳定性设计**：
- 假设所有外部调用都可能失败
- 合理使用try-catch处理异常
- 通过返回None优雅处理错误情况

### 进阶开发技巧

**扩展事件利用**：理解扩展事件机制，选择合适的事件粒度处理

**历史记录分析**：利用Librarian实现上下文相关的智能回复

**配置驱动设计**：通过配置控制插件行为，在INITIALIZER中建立默认配置

**API组合使用**：结合查询API和返回值API实现复杂交互逻辑

**调试策略**：充分利用日志记录和返回值调试插件行为

## 框架定位与选择指南

### 适合Askr的场景

**学习与原型环境**：
- 新手开发者学习QQ机器人开发
- 快速验证想法和功能原型

**稳定性优先场景**：
- 无法容忍插件错误影响整体服务
- 需要运行多个不同来源的插件
- 团队中包含编程新手

### 不适合Askr的场景

**高性能要求场景**：
- 需要毫秒级响应的高频交互
- 需要长时间CPU密集计算的任务
- 严格的实时性响应要求

**复杂应用场景**：
- 需要插件间复杂交互的应用
- 复杂的状态管理需求
- 需要高度定制化的业务逻辑

### 与其他框架的定位差异

**设计理念差异**：
- **目标用户**：新手开发者，而主流框架面向有经验的开发者
- **核心价值**：稳定性和易用性，而主流框架注重性能和功能完整性
- **学习曲线**：平缓渐进，而主流框架通常陡峭但强大

**技术选择对比**：
- **进程隔离而不是协程**：绝对错误隔离、资源控制，但有性能开销
- **事件驱动而不是对象模型**：概念简单、接口一致，但功能表达受限
- **配置内置而不是外部管理**：开箱即用、自动命名空间，但灵活性受限

**选择建议**：
- **适合选择Askr**：团队有新手、稳定性优先、多插件协作、快速原型需求
- **可能更适合其他框架**：极致性能需求、复杂业务逻辑、团队技术能力强、高度定制化需求

Askr Framework的价值在于为特定场景和用户群体提供了一个独特的解决方案。它不试图成为最强大或最快的框架，而是专注于成为最适合新手开发者和稳定性优先场景的框架。通过明确的定位和权衡，它在目标领域内提供了卓越的开发体验。

如果你还想了解更多关于插件本身的细节，请参阅[架构细节](architecture.md)
